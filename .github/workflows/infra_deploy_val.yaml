name: Terraform PR Validation

on:
  workflow_dispatch:
    inputs:
      vpu:
        description: 'VPU to test (e.g., 01, 02, 03N, 03S, etc.)'
        required: false
        default: '01'
        type: string
      date:
        description: 'Date for testing (YYYYMMDD format)'
        required: false
        default: '20250905'
        type: string
  # push:
  #   branches:
  #     - main
  #     - feature/infra-deployment
  #   paths:
  #     - 'infra/aws/terraform/modules/orchestration/**'
  #     - 'infra/aws/terraform/main.tf'
  #     - 'infra/aws/terraform/variables-test.tfvars'
  #     - 'infra/aws/terraform/backend-test.hcl'
  #     - '.github/workflows/infra_deploy_val.yaml'
  # pull_request:
  #   branches:
  #     - main
  #     - feature/infra-deployment
  #   paths:
  #     - 'infra/aws/terraform/modules/orchestration/**'
  #     - 'infra/aws/terraform/main.tf'
  #     - 'infra/aws/terraform/variables-test.tfvars'
  #     - 'infra/aws/terraform/backend-test.hcl'

concurrency:
  group: test-infra-deployment
  cancel-in-progress: true  # Cancel old run if new one starts

env:
  TF_VAR_FILE: variables-test.tfvars  # Test-specific variables to avoid conflicts
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: 1.10.0
  ENVIRONMENT: test  # Separate environment from dev/prod 


jobs:
  generate-executions:
    name: Generate VPU Execution Files
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'
    
    - name: Install Python dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq
        pip install --upgrade pip
        pip install --upgrade awscli
        pip install --upgrade awscli boto3 pandas

    - name: Configure AWS Credentials (OIDC)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-GenerateExecutions
 

    - name: Generate execution files
      working-directory: infra/aws
      run: |
        echo "Working directory: $(pwd)"
        echo "Generating VPU execution files..."
        python python/src/research_datastream/gen_vpu_execs.py \
        --arch arm \
        --inputs terraform/modules/schedules/config/execution_forecast_inputs.json \
        --ami_file terraform/modules/schedules/config/community_ami.txt \
        --exec_template_vpu terraform/modules/schedules/executions/templates/execution_datastream_VPU_template.json \
        --exec_template_fp terraform/modules/schedules/executions/templates/execution_datastream_fp_template.json \
        --out_dir terraform/modules/schedules/executions

        echo "::notice::Execution files generated successfully"

  terraform-check:
    name: Terraform Quality Checks
    needs: generate-executions
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: infra/aws/terraform
    
    permissions:
      contents: read
      pull-requests: write
      id-token: write
      security-events: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'
    
    - name: Install Python dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq
        pip install --upgrade pip
        pip install --upgrade awscli
        pip install --upgrade awscli boto3 pandas

    - name: Configure AWS Credentials (OIDC)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-TerraformCheck

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false

    - name: Auto-format Terraform files
      run: terraform fmt -recursive

    - name: Terraform Format Check
      id: fmt
      run: terraform fmt -check -recursive
      continue-on-error: true
    
    - name: Terraform Init
      id: init
      run: terraform init -backend-config=backend-${ENVIRONMENT}.hcl

    - name: Terraform Validate
      id: validate
      run: terraform validate -no-color
    
    - name: Check for tfvars files
      id: check_tfvars
      run: |
        echo "Checking for required tfvars files..."
        
        # Check if the main tfvars file exists
        if [ ! -f "${{ env.TF_VAR_FILE }}" ]; then
          echo "::error::Missing required tfvars file: ${{ env.TF_VAR_FILE }}"
          exit 1
        fi
        
        echo "::notice::Found tfvars file: ${{ env.TF_VAR_FILE }}"
        
        # Validate tfvars syntax
        terraform fmt -check "${{ env.TF_VAR_FILE }}" || {
          echo "::warning::File ${{ env.TF_VAR_FILE }} is not properly formatted"
        }
        
        # Optionally check for environment-specific tfvars if they exist
        if [ -d "environments" ]; then
          tfvars_count=$(find environments -name "*.tfvars" -type f | wc -l)
          if [ "$tfvars_count" -gt 0 ]; then
            echo "::notice::Found $tfvars_count additional environment tfvars file(s)"
            find environments -name "*.tfvars" -type f
          fi
        fi

    - name: Run tfsec Security Scan
      id: tfsec
      uses: aquasecurity/tfsec-pr-commenter-action@v1.3.1
      with:
        github_token: ${{ github.token }}
        working_directory: infra/aws/terraform
        soft_fail_commenter: true
    
    - name: Run Checkov Security Scan
      id: checkov
      uses: bridgecrewio/checkov-action@v12
      with:
        directory: infra/aws/terraform
        framework: terraform
        output_format: cli,sarif
        output_file_path: console,results.sarif
        soft_fail: true
    
    - name: Upload Checkov Results
      if: always()
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: results.sarif
      continue-on-error: true
    
    - name: Terraform Plan
      id: plan
      run: |
        terraform plan -var-file=./${{ env.TF_VAR_FILE }} -no-color -out=tfplan
        terraform show -no-color tfplan > plan_output.txt
      continue-on-error: true
    
    - name: Upload Plan Artifact
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan-${{ github.sha }}
        path: infra/aws/terraform/tfplan
        retention-days: 10
    
    - name: Upload Plan Output
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan-output-${{ github.sha }}
        path: infra/aws/terraform/plan_output.txt
        retention-days: 10
    
    - name: Check for Plan Failures
      if: steps.plan.outcome == 'failure'
      run: |
        echo "::warning::Terraform plan failed but continuing workflow"
        echo "Plan failed with errors. Check the plan output for details."
      continue-on-error: true
    
    - name: Check for Format Failures
      if: steps.fmt.outcome == 'failure'
      run: |
        echo "::error::Terraform files are not properly formatted. Run 'terraform fmt -recursive' locally."
      continue-on-error: true
    
        
  terraform-apply:
    name: Terraform Apply
    needs: terraform-check
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: infra/aws/terraform
    
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'
    
    - name: Install Python dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq
        pip install --upgrade pip
        pip install --upgrade awscli boto3 pandas

    - name: Configure AWS Credentials (OIDC)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-TerraformApply

    - name: Generate execution files
      working-directory: infra/aws
      run: |
        echo "Working directory: $(pwd)"
        echo "Generating VPU execution files..."
        python python/src/research_datastream/gen_vpu_execs.py \
        --arch arm \
        --inputs terraform/modules/schedules/config/execution_forecast_inputs.json \
        --ami_file terraform/modules/schedules/config/community_ami.txt \
        --exec_template_vpu terraform/modules/schedules/executions/templates/execution_datastream_VPU_template.json \
        --exec_template_fp terraform/modules/schedules/executions/templates/execution_datastream_fp_template.json \
        --out_dir terraform/modules/schedules/executions

        echo "::notice::Execution files generated successfully"
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false

    - name: Auto-format Terraform files
      run: terraform fmt -recursive

    - name: Terraform Init
      run:  terraform init -backend-config=backend-${ENVIRONMENT}.hcl

    - name: Download Plan Artifact
      uses: actions/download-artifact@v4
      with:
        name: terraform-plan-${{ github.sha }}
        path: infra/aws/terraform

    - name: Terraform Apply
      id: apply
      run: |
        echo "::notice::Starting Terraform Apply..."
        terraform apply -var-file="variables-${ENVIRONMENT}.tfvars" -auto-approve
        echo "::notice::Terraform Apply completed successfully"
    
    - name: Terraform Output
      if: success()
      run: |
        echo "::group::Terraform Outputs"
        terraform output -json > terraform_outputs.json
        cat terraform_outputs.json
        echo "::endgroup::"
    
    - name: Upload Terraform Outputs
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: terraform-outputs-${{ github.sha }}
        path: infra/aws/terraform/terraform_outputs.json
        retention-days: 10

    - name: Wait for IAM propagation
      if: success()
      run: |
        echo "::notice::Waiting 2 minutes for IAM permissions to propagate across AWS services..."
        sleep 120
        echo "::notice::IAM propagation wait complete"

  test-short-range-vpus:
    name: Test Single VPU Execution
    runs-on: ubuntu-latest
    needs: terraform-apply
    timeout-minutes: 60
    permissions:
      id-token: write
      contents: read

    env:
      VPU: ${{ inputs.vpu || '01' }}  # Use workflow input or default to '01'
      RUN_TYPE: short_range
      ENSEMBLE_MEMBER: ""
      DATE: ${{ inputs.date || '20250905' }}  # Use workflow input or default
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-TestVPU-${{ env.VPU }}
          role-duration-seconds: 7200  # 2 hours

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          pip install --upgrade awscli boto3 pandas

      - name: Generate execution files using Python script
        run: |
          cd infra/aws
          python python/src/research_datastream/gen_vpu_execs.py \
            --arch arm \
            --inputs terraform/modules/schedules/config/execution_forecast_inputs.json \
            --ami_file terraform/modules/schedules/config/community_ami.txt \
            --exec_template_vpu terraform/modules/schedules/executions/templates/execution_datastream_VPU_template.json \
            --exec_template_fp terraform/modules/schedules/executions/templates/execution_datastream_fp_template.json \
            --out_dir test_executions

      - name: Set execution file path
        id: set_path
        run: |
          cd infra/aws
          RUN_TYPE="${{ env.RUN_TYPE }}"
          VPU="${{ env.VPU }}"
          ENSEMBLE="${{ env.ENSEMBLE_MEMBER }}"

          if [ "$RUN_TYPE" = "short_range" ]; then
            EXEC_PATH="test_executions/short_range/00/execution_datastream_${VPU}.json"
          elif [ "$RUN_TYPE" = "medium_range" ]; then
            EXEC_PATH="test_executions/medium_range/00/${ENSEMBLE}/execution_datastream_${VPU}.json"
          elif [ "$RUN_TYPE" = "analysis_assim_extend" ]; then
            EXEC_PATH="test_executions/analysis_assim_extend/16/execution_datastream_${VPU}.json"
          fi

          echo "exec_path=$EXEC_PATH" >> "$GITHUB_OUTPUT"
          echo "Execution file path: $EXEC_PATH"

      - name: Modify execution for testing
        run: |
          cd infra/aws
          EXEC_FILE="${{ steps.set_path.outputs.exec_path }}"
          RUN_TYPE="${{ env.RUN_TYPE }}"
          VPU="${{ env.VPU }}"
          DATE="${{ env.DATE }}"

          # Use Python script to modify execution file (preserves escape sequences)
          python3 ../../.github/scripts/modify_execution.py \
            "$EXEC_FILE" \
            "temp_execution.json" \
            "$RUN_TYPE" \
            "$VPU" \
            "$DATE" \
            "${{ github.run_id }}"

          mv "temp_execution.json" "$EXEC_FILE"
          cat "$EXEC_FILE"          

      - name: Check and create AWS key pair
        run: |
          if ! aws ec2 describe-key-pairs --key-names "actions_key" --query 'KeyPairs[0].KeyName' --output text 2>/dev/null; then 
            aws ec2 create-key-pair --key-name "actions_key" --query 'KeyName' --output text
            echo "Key pair 'actions_key' created"
          else 
            echo "Key pair 'actions_key' already exists"
          fi

      - name: Get State Machine ARN
        id: get_sm_arn
        run: |
          # Get test state machine ARN
          ARN=$(aws stepfunctions describe-state-machine \
            --state-machine-arn "arn:aws:states:${{ env.AWS_REGION }}:$(aws sts get-caller-identity --query Account --output text):stateMachine:nrds_test_sm" \
            --query 'stateMachineArn' \
            --output text \
            --region ${{ env.AWS_REGION }})
          echo "arn=$ARN" >> "$GITHUB_OUTPUT"
          echo "State Machine ARN: $ARN"

      - name: Start and monitor Step Functions execution
        id: stepfunction
        run: |
          cd infra/aws
          EXEC_FILE="${{ steps.set_path.outputs.exec_path }}"
          RUN_TYPE="${{ env.RUN_TYPE }}"
          VPU="${{ env.VPU }}"

          cat "$EXEC_FILE"
          TS=$(env TZ=US/Eastern date +'%Y%m%d%H%M%S%3N')   # ms resolution

          # Create run type prefix for execution name
          if [ "$RUN_TYPE" = "short_range" ]; then
            PREFIX="sr"
          elif [ "$RUN_TYPE" = "medium_range" ]; then
            PREFIX="mr"
          elif [ "$RUN_TYPE" = "analysis_assim_extend" ]; then
            PREFIX="aae"
          fi

          NAME="${PREFIX}-vpu-${VPU}-${TS}-${{ github.run_id }}-${{ github.run_attempt }}"
          execution_arn=$(aws stepfunctions start-execution \
            --state-machine-arn "${{ steps.get_sm_arn.outputs.arn }}" \
            --name "$NAME" \
            --input "file://$EXEC_FILE" \
            --region ${{ env.AWS_REGION }} \
            --query 'executionArn' --output text)

          echo "Execution ARN: $execution_arn"

          status="RUNNING"
          while [ "$status" != "SUCCEEDED" ]; do
            status=$(aws stepfunctions describe-execution --execution-arn "$execution_arn" --region ${{ env.AWS_REGION }} --query 'status' --output text)
            echo "Current status: $status"
            if [ "$status" == "FAILED" ] || [ "$status" == "TIMED_OUT" ] || [ "$status" == "ABORTED" ]; then
              echo "State machine execution failed with status: $status for $RUN_TYPE VPU $VPU!"
              aws stepfunctions describe-execution --execution-arn "$execution_arn" --region ${{ env.AWS_REGION }}
              echo "stepfunction_failed=true" >> "$GITHUB_OUTPUT"
              exit 1
            fi
            sleep 5
          done
          echo "State machine execution succeeded for $RUN_TYPE VPU $VPU!"
          echo "stepfunction_failed=false" >> "$GITHUB_OUTPUT"
           
      - name: Verify output files
        run: |
          RUN_TYPE="${{ env.RUN_TYPE }}"
          VPU="${{ env.VPU }}"

          echo "Checking if processing created output files for $RUN_TYPE VPU $VPU..."

          file_list=$(aws s3 ls s3://ciroh-community-ngen-datastream/tests/${RUN_TYPE}/VPU_${VPU}/ --recursive 2>/dev/null || echo "")

          if [ -n "$file_list" ]; then
            echo "SUCCESS: VPU $VPU processing completed!"
            echo "$file_list"
            file_count=$(echo "$file_list" | wc -l)
            echo "Total files created for VPU $VPU: $file_count ($RUN_TYPE)"
          else
            echo "FAILED: No output files created for $RUN_TYPE VPU $VPU"
            exit 1
          fi

      - name: Verify specific file
        run: |
          RUN_TYPE="${{ env.RUN_TYPE }}"
          VPU="${{ env.VPU }}"

          curl -fSs -o test.txt https://ciroh-community-ngen-datastream.s3.amazonaws.com/tests/${RUN_TYPE}/VPU_${VPU}/ngen-run.tar.gz || {
            echo "Error: File not found or request failed"; exit 1;
          } 
          
      - name: Clean up
        if: always()
        run: |
          RUN_TYPE="${{ env.RUN_TYPE }}"
          VPU="${{ env.VPU }}"
          aws s3 rm --recursive s3://ciroh-community-ngen-datastream/tests/${RUN_TYPE}/VPU_${VPU} || echo "No files to delete for $RUN_TYPE VPU $VPU"

  # TEMPORARILY DISABLED: Medium-range tests are hanging/failing - investigating
  # test-medium-range-vpus:
  #   runs-on: ubuntu-latest
  #   needs: terraform-apply
  #   timeout-minutes: 300
  #   strategy:
  #     fail-fast: false
  #     max-parallel: 15
  #     matrix:
  #       vpu: ["01", "02", "03N", "03S", "03W", "04", "05", "06", "07", "08", "09", "10L", "10U", "11", "12", "13", "14", "15", "16", "17", "18"]
  #   permissions:
  #     id-token: write
  #     contents: read

  #   env:
  #     VPU: ${{ matrix.vpu }}
  #     RUN_TYPE: medium_range
  #     ENSEMBLE_MEMBER: "1"
  #     DATE: 20250905

  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4

  #     - name: Configure AWS Credentials (OIDC)
  #       uses: aws-actions/configure-aws-credentials@v4
  #       with:
  #         role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
  #         aws-region: ${{ env.AWS_REGION }}
  #         role-session-name: GitHubActions-TestVPU-${{ matrix.vpu }}
  #         role-duration-seconds: 7200  # 2 hours

  #     - name: Set up Python
  #       uses: actions/setup-python@v5
  #       with:
  #         python-version: '3.x'

  #     - name: Install dependencies
  #       run: |
  #         sudo apt-get update
  #         sudo apt-get install -y jq
  #         pip install --upgrade awscli boto3 pandas

  #     - name: Generate execution files using Python script
  #       run: |
  #         cd infra/aws
  #         python python/src/research_datastream/gen_vpu_execs.py \
  #           --arch arm \
  #           --inputs terraform/modules/schedules/config/execution_forecast_inputs.json \
  #           --ami_file terraform/modules/schedules/config/community_ami.txt \
  #           --exec_template_vpu terraform/modules/schedules/executions/templates/execution_datastream_VPU_template.json \
  #           --exec_template_fp terraform/modules/schedules/executions/templates/execution_datastream_fp_template.json \
  #           --out_dir test_executions

  #     - name: Set execution file path
  #       id: set_path
  #       run: |
  #         cd infra/aws
  #         RUN_TYPE="${{ env.RUN_TYPE }}"
  #         VPU="${{ env.VPU }}"
  #         ENSEMBLE="${{ env.ENSEMBLE_MEMBER }}"

  #         if [ "$RUN_TYPE" = "short_range" ]; then
  #           EXEC_PATH="test_executions/short_range/00/execution_datastream_${VPU}.json"
  #         elif [ "$RUN_TYPE" = "medium_range" ]; then
  #           EXEC_PATH="test_executions/medium_range/00/${ENSEMBLE}/execution_datastream_${VPU}.json"
  #         elif [ "$RUN_TYPE" = "analysis_assim_extend" ]; then
  #           EXEC_PATH="test_executions/analysis_assim_extend/16/execution_datastream_${VPU}.json"
  #         fi

  #         echo "exec_path=$EXEC_PATH" >> "$GITHUB_OUTPUT"
  #         echo "Execution file path: $EXEC_PATH"

  #     - name: Modify execution for testing
  #       run: |
  #         cd infra/aws
  #         EXEC_FILE="${{ steps.set_path.outputs.exec_path }}"
  #         RUN_TYPE="${{ env.RUN_TYPE }}"
  #         VPU="${{ env.VPU }}"
  #         DATE="${{ env.DATE }}"

  #         # Use Python script to modify execution file (preserves escape sequences)
  #         python3 ../../.github/scripts/modify_execution.py \
  #           "$EXEC_FILE" \
  #           "temp_execution.json" \
  #           "$RUN_TYPE" \
  #           "$VPU" \
  #           "$DATE"

  #         mv "temp_execution.json" "$EXEC_FILE"
  #         cat "$EXEC_FILE"

  #     - name: Check and create AWS key pair
  #       run: |
  #         if ! aws ec2 describe-key-pairs --key-names "actions_key" --query 'KeyPairs[0].KeyName' --output text 2>/dev/null; then
  #           aws ec2 create-key-pair --key-name "actions_key" --query 'KeyName' --output text
  #           echo "Key pair 'actions_key' created"
  #         else
  #           echo "Key pair 'actions_key' already exists"
  #         fi

  #     - name: Get State Machine ARN
  #       id: get_sm_arn
  #       run: |
  #         ARN=$(aws ssm get-parameter \
  #           --name "/datastream/state-machine-arn" \
  #           --with-decryption \
  #           --query 'Parameter.Value' \
  #           --output text \
  #           --region ${{ env.AWS_REGION }})
  #         echo "arn=$ARN" >> "$GITHUB_OUTPUT"
  #         echo "State Machine ARN: $ARN"

  #     - name: Start and monitor Step Functions execution
  #       id: stepfunction
  #       run: |
  #         cd infra/aws
  #         EXEC_FILE="${{ steps.set_path.outputs.exec_path }}"
  #         RUN_TYPE="${{ env.RUN_TYPE }}"
  #         VPU="${{ env.VPU }}"

  #         cat "$EXEC_FILE"
  #         TS=$(env TZ=US/Eastern date +'%Y%m%d%H%M%S%3N')   # ms resolution

  #         # Create run type prefix for execution name
  #         if [ "$RUN_TYPE" = "short_range" ]; then
  #           PREFIX="sr"
  #         elif [ "$RUN_TYPE" = "medium_range" ]; then
  #           PREFIX="mr"
  #         elif [ "$RUN_TYPE" = "analysis_assim_extend" ]; then
  #           PREFIX="aae"
  #         fi

  #         NAME="${PREFIX}-vpu-${VPU}-${TS}-${{ github.run_id }}-${{ github.run_attempt }}"
  #         execution_arn=$(aws stepfunctions start-execution \
  #           --state-machine-arn $(aws ssm get-parameter --name "/datastream/state-machine-arn" --with-decryption --query 'Parameter.Value' --output text) \
  #           --name "$NAME" \
  #           --input "file://$EXEC_FILE" \
  #           --region ${{ env.AWS_REGION }} \
  #           --query 'executionArn' --output text)

  #         echo "Execution ARN: $execution_arn"

  #         status="RUNNING"
  #         while [ "$status" != "SUCCEEDED" ]; do
  #           status=$(aws stepfunctions describe-execution --execution-arn "$execution_arn" --region ${{ env.AWS_REGION }} --query 'status' --output text)
  #           echo "Current status: $status"
  #           if [ "$status" == "FAILED" ] || [ "$status" == "TIMED_OUT" ] || [ "$status" == "ABORTED" ]; then
  #             echo "State machine execution failed with status: $status for $RUN_TYPE VPU $VPU!"
  #             aws stepfunctions describe-execution --execution-arn "$execution_arn" --region ${{ env.AWS_REGION }}
  #             echo "stepfunction_failed=true" >> "$GITHUB_OUTPUT"
  #             exit 1
  #           fi
  #           sleep 5
  #         done
  #         echo "State machine execution succeeded for $RUN_TYPE VPU $VPU!"
  #         echo "stepfunction_failed=false" >> "$GITHUB_OUTPUT"

  #     - name: Verify output files
  #       if: matrix.vpu != '10U' && matrix.vpu != '17'
  #       run: |
  #         RUN_TYPE="${{ env.RUN_TYPE }}"
  #         VPU="${{ env.VPU }}"

  #         echo "Checking if processing created output files for $RUN_TYPE VPU $VPU..."

  #         file_list=$(aws s3 ls s3://ciroh-community-ngen-datastream/tests/${RUN_TYPE}/VPU_${VPU}/ --recursive 2>/dev/null || echo "")

  #         if [ -n "$file_list" ]; then
  #           echo "SUCCESS: VPU $VPU processing completed!"
  #           echo "$file_list"
  #           file_count=$(echo "$file_list" | wc -l)
  #           echo "Total files created for VPU $VPU: $file_count ($RUN_TYPE)"
  #         else
  #           echo "FAILED: No output files created for $RUN_TYPE VPU $VPU"
  #           exit 1
  #         fi

  #     - name: Verify specific file
  #       if: matrix.vpu != '10U' && matrix.vpu != '17'
  #       run: |
  #         RUN_TYPE="${{ env.RUN_TYPE }}"
  #         VPU="${{ env.VPU }}"

  #         curl -fSs -o test.txt https://ciroh-community-ngen-datastream.s3.amazonaws.com/tests/${RUN_TYPE}/VPU_${VPU}/ngen-run.tar.gz || {
  #           echo "Error: File not found or request failed"; exit 1;
  #         }

  #     - name: Clean up
  #       if: always()
  #       run: |
  #         RUN_TYPE="${{ env.RUN_TYPE }}"
  #         VPU="${{ env.VPU }}"
  #         aws s3 rm --recursive s3://ciroh-community-ngen-datastream/tests/${RUN_TYPE}/VPU_${VPU} || echo "No files to delete for $RUN_TYPE VPU $VPU"

  terraform-destroy:
    name: Terraform Destroy Test Resources
    needs: [test-short-range-vpus]
    runs-on: ubuntu-latest
    if: success()  # Only destroy on success, leave resources for debugging on failure
    defaults:
      run:
        working-directory: infra/aws/terraform

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-TerraformDestroy
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Auto-format Terraform files
        run: terraform fmt -recursive
        continue-on-error: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          pip install --upgrade pip awscli boto3 pandas

      - name: Generate execution files
        working-directory: infra/aws
        run: |
          echo "Working directory: $(pwd)"
          echo "Generating VPU execution files..."
          python python/src/research_datastream/gen_vpu_execs.py \
            --arch arm \
            --inputs terraform/modules/schedules/config/execution_forecast_inputs.json \
            --ami_file terraform/modules/schedules/config/community_ami.txt \
            --exec_template_vpu terraform/modules/schedules/executions/templates/execution_datastream_VPU_template.json \
            --exec_template_fp terraform/modules/schedules/executions/templates/execution_datastream_fp_template.json \
            --out_dir terraform/modules/schedules/executions
          echo "::notice::Execution files generated successfully"


      - name: Terraform Init
        run: terraform init -backend-config=backend-${ENVIRONMENT}.hcl
        continue-on-error: true

      - name: Verify State Has Resources
        run: |
          RESOURCE_COUNT=$(terraform state list 2>/dev/null | wc -l)
          echo "::notice::Found $RESOURCE_COUNT resources in state"
          if [ "$RESOURCE_COUNT" -eq 0 ]; then
            echo "::warning::No resources in state to destroy!"
          else
            terraform state list
          fi
        continue-on-error: true
        
      
      - name: Stop Test Step Functions Executions
        run: |
          echo "Stopping test Step Functions executions..."

          # Use test state machine
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          STATE_MACHINE_ARN="arn:aws:states:${{ env.AWS_REGION }}:${AWS_ACCOUNT_ID}:stateMachine:nrds_test_sm"

          # Check if state machine exists
          if aws stepfunctions describe-state-machine --state-machine-arn "$STATE_MACHINE_ARN" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            # Stop all running executions matching test pattern (sr=short_range, mr=medium_range, aae=analysis_assim_extend)
            aws stepfunctions list-executions \
              --state-machine-arn "$STATE_MACHINE_ARN" \
              --status-filter RUNNING \
              --region ${{ env.AWS_REGION }} \
              --query 'executions[*].[executionArn,name]' \
              --output text | while read arn name; do
                if [[ "$name" =~ ^(sr|mr|aae)-vpu-.* ]]; then
                  echo "Stopping test execution: $name"
                  aws stepfunctions stop-execution \
                    --execution-arn "$arn" \
                    --region ${{ env.AWS_REGION }} 2>/dev/null || true
                fi
              done
          fi
        continue-on-error: true

      - name: Terminate Orphaned Test EC2 Instances
        if: always()
        run: |
          echo "Checking for orphaned test EC2 instances from this workflow run..."

          # Get all running/pending instances created by THIS workflow run only
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters \
              "Name=tag:GitHubRunId,Values=${{ github.run_id }}" \
              "Name=instance-state-name,Values=running,pending" \
            --query 'Reservations[*].Instances[*].[InstanceId,Tags[?Key==`Project`].Value|[0],LaunchTime]' \
            --output text)

          if [ -z "$INSTANCE_IDS" ]; then
            echo "✓ No orphaned test instances found for run ${{ github.run_id }}"
          else
            echo "Found orphaned instances from run ${{ github.run_id }}:"
            echo "$INSTANCE_IDS"

            # Extract just instance IDs
            INSTANCE_LIST=$(echo "$INSTANCE_IDS" | awk '{print $1}' | tr '\n' ' ')

            if [ -n "$INSTANCE_LIST" ]; then
              echo "Terminating instances: $INSTANCE_LIST"
              aws ec2 terminate-instances --instance-ids $INSTANCE_LIST || echo "Failed to terminate some instances"

              # Count terminated instances
              INSTANCE_COUNT=$(echo $INSTANCE_LIST | wc -w)
              echo "✓ Terminated $INSTANCE_COUNT orphaned test instances"
            fi
          fi
        continue-on-error: true

      - name: Terraform Destroy
        id: destroy_attempt
        run: |
          echo "::notice::Starting Terraform Destroy (Attempt 1)..."
          terraform destroy -var-file=./${{ env.TF_VAR_FILE }} -auto-approve
          echo "::notice::Terraform Destroy completed successfully"
        continue-on-error: true
      
      
      - name: Final State Check
        if: always()
        run: |
          REMAINING=$(terraform state list 2>/dev/null | wc -l)
          if [ "$REMAINING" -gt 0 ]; then
            echo "::warning::$REMAINING resources still in state"
            terraform state list
          else
            echo "::notice::All Terraform resources destroyed"
          fi
        continue-on-error: true
